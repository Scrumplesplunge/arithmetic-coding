#include "intervals.h"

#include <stdexcept>
#include <iostream>

using namespace std;

const bound Intervals::ONE = 0x0000000080000000ULL;

bound Intervals::within(bound min, bound max, bound value) {
  bound size = max - min;
  return min + size * value / Intervals::ONE;
}

// Construct a new instance with intervals for codes [0..num_codes).
Intervals::Intervals(int num_codes)
    : num_codes_(num_codes), codes_(new bound[num_codes + 1]),
      frequency_(new count[num_codes]) {
  for (int i = 0; i < num_codes; i++) frequency_[i] = 1;
  UpdateIntervals();
}

// Fetch the (inclusive) lower bound for the given code.
bound Intervals::lower(int code) const {
  check_bounds(code);
  return codes_[code];
}

// Fetch the (exclusive) upper bound for the given code.
bound Intervals::upper(int code) const {
  check_bounds(code);
  return codes_[code + 1];
}

// Computes the code which is represented by every extension of the bound x.
// Returns true and populates the output only if such a code was found.
bool Intervals::CodeAt(
    bound min, bound max, bound min_value, bound max_value, int* code) const {
  // Binary search (by the lower bound) for an interval which contains the one
  // given.
  int i = 0, j = num_codes_;
  while (i + 1 < j) {
    int mid = (i + j) / 2;
    if (within(min, max, codes_[mid]) <= min_value) {
      // codes_[mid] comes before the lower bound of the given interval, so it
      // (as well as possibly larger indices) is a valid candidate.
      i = mid;
    } else {
      // codes_[mid] comes after the lower bound, so any valid candidates must
      // comes strictly before this one.
      j = mid;
    }
  }
  // At this point, i is the largest code for which the lower bound is less than
  // or equal to the lower bound of the provided interval. Thus, we only need to
  // check the upper bound.
  if (within(min, max, codes_[i + 1]) >= max_value) {
    // The interval for this code includes the given interval entirely.
    // cout << "[" << min_value << ", " << max_value << ") is in ["
    //      << within(min, max, codes_[i]) << ", "
    //      << within(min, max, codes_[i + 1]) << ")\n";
    *code = i;
    return true;
  } else {
    // The upper bound for this code does not encapsulate the interval.
    // Therefore, no such code exists.
    return false;
  }
}

// Set the relative frequency of the specified code to the given value.
void Intervals::SetFrequency(int code, count frequency) {
  check_bounds(code);
  frequency_[code] = frequency;
  UpdateIntervals();
}

// Get the relative frequency of the specified code.
count Intervals::frequency(int code) const {
  check_bounds(code);
  return frequency_[code];
}

// Check that the given code index is within the acceptable bounds for this
// instance.
void Intervals::check_bounds(int code) const {
  if (code < 0 || num_codes_ <= code)
    throw runtime_error("Symbol code out of bounds.");
}

// Recompute the interval bounds based upon the relative frequency values.
void Intervals::UpdateIntervals() {
  // Calculate the frequency total.
  count frequency_total = 0;
  for (int i = 0; i < num_codes_; i++) frequency_total += frequency_[i];

  // If the frequency totals exceed the bound, reduce all the frequencies. This
  // recurses, so it will repeat as many times as necessary.
  if (frequency_total > ONE) return WeakenFrequencies();

  // Recompute and store all the bounds.
  count cumulative_frequency = 0;
  codes_[0] = 0;
  for (int i = 0; i < num_codes_; i++) {
    cumulative_frequency += frequency_[i];
    codes_[i + 1] = ONE * cumulative_frequency / frequency_total;

    if (codes_[i + 1] == codes_[i])
      throw logic_error("Bounds for a code coalesced.");
  }

  // Throw an error if this does not turn out as we would expect.
  if (codes_[num_codes_] != ONE)
    throw logic_error("Maximum upper bound != 1.");
}

// Reduce all relative frequencies by a factor of 2, except those which are 1.
void Intervals::WeakenFrequencies() {
  for (int i = 0; i < num_codes_; i++) {
    if (frequency_[i] > 1) frequency_[i] /= 2;
  }
  UpdateIntervals();
}
